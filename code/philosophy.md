哲学（may）
=======

这里列出的是一些哲学性质的思考，主要关注的是黑与白之间的灰色地带，即无所谓明显的对与错，尽量从多方面的角度提供参考，属于经验的积累。

从某种程度上说这里的东西是一种感觉或者直觉，请尽量理解，做到心中有剑。

# 1. “静态”优于“动态”

静态特性指的是在编译阶段生效的特性，而动态特性指的是在运行阶段生效的特性。

以Javascript的模块加载为例：

```js
// CommonJS规范
const lodash = require('lodash');

// ES6规范
import lodash from 'lodash';
```

上面的例子看似没什么区别，但CommonJS是动态的，ES6是静态的，因为CommonJS允许运行时才确定require的路径，甚至允许运行时才确定是否引用一个模块，比如下面这样：

```js
const dependencyName = 'lodash';

// 运行时才确定依赖的名字，这在CommonJS规范里这是合法的
const lodash = require(dependencyName);

// 运行时才确定是否依赖一个模块，这在CommonJS规范里这也是合法的
if (condition) {
  const lodash = require('lodash');
}
```

而ES6无法做到上面这些写法，因为上面的写法无法在编译时确定依赖关系。

> 注：dynamic import不是ES6规范

类似的例子还有很多，比如Javascript的OOP写法：原生Js的原型链和ES6引入的class，其中原型链是动态特性，class是静态特性。因为原型链写法中一个类的行为是在运行时才确定下来的，而class是无法在运行是改变行为的。

静态特性相比于动态特性有以下2个优势：

1. 行为稳定易于理解和优化。在编译阶段分析代码即可确定代码的逻辑行为，到了运行时仍然能保持一致。不论是对人、IDE还是编译器都十分友好。典型的例子是IDE的代码提示和补全。
2. 降低修复错误的成本。在编译时就可以发现各种错误，不用等到上线后才发现问题然后紧急修复。典型的例子是eslint的错误检测。

在多人合作的大型项目里，上面两个优势会被成倍地放大。

因此，当实现一种行为有静态和动态两种方式时，应当优先考虑静态写法。一个坏的例子是webpack的源码，充满了大量动态注入行为，光看代码几乎无法理解，其实那些功能用静态写法也可以做到，只是可能代码量会多一些罢了。

最后，静态特性自然也有不足的地方，比如无法动态修改逻辑，灵活性差。如果代码行为是由运行时的数据决定的，静态写法就必须提前穷举所有可能的情况以确保在运行时能正确执行，写起来很死板很啰嗦，万一数据很难提前穷举，此时静态写法就非常困难。在这种情况下，动态写法是更好的选择。

# 2. “显式”优于“隐式”

“显式”和“隐式”的区别主要在于代码本身的含义是否明显，代码的依赖是否明显。如果很明显，那就是显式的，否则是隐式的。

最简单的例子就是变量命名了：

```js
function iterator(arg1, arg2) {
  ...
}
```

单看函数名字完全不知道是做什么的，如果想知道他是做什么的以及怎么用则必须阅读相关代码，这就是一个隐式的例子，因为代码的效果不够明显。
如果改成下面这样就清楚多了：

```js
function calculateInterviewConflict(arg1, arg2) {
  ...
}
```

除了变量命名外，有的是代码本身的依赖不够明显，比如：

```js
function doSomething1() {
  ...
}

function doSomething2() {
  ...
}
```

此处业务逻辑的关系，隐含了一个限制条件，即这两个函数必须先调用`doSomething1`，再调用`doSomething2`，否则会得到错误的结果。
而这个约定是隐式的，因为单纯从代码上看是无法得知的，除非对代码逻辑本身有足够的了解。

改成显式的做法是：

```js
function doSomething1() {
  ...
}

// 现在至少从函数名字上是显式写法了
function doSomething2AfterSomething1() {
  ...
}
```

因为显式写法需要暴露更多信息，所以通常比隐式写法更加啰嗦。比如变量名更长或者代码行数更多，从这个角度来说会降低开发效率，对开发者来说体验不是很好。但当多人协作时，显式写法节省了大量沟通成本，实际上对开发者而言效率和体验其实更好。

另外有一种“约定大于配置”的开发策略，这种开发策略是显式还是隐式呢？其实要看这个约定是否被大家承认和尊重。世上本没有路，走的人多了自然就成了路。很多写法是隐式的，但如果约定落地得好，就可以不认为是隐式的。约定式开发是试图找到一种既易于理解又写法简洁的平衡。但这个比较依赖规范的执行情况，也是有一定风险和代价。

从某种程度上说，“显式”和“隐式”可以类比与“简单”与“简洁”。

# 3. “组合”优于“继承”

组合和继承是代码复用的两种方式。

继承是经典的OOP思想，例如：

```js
class Fruit {
  eat: () => {
    ...
  }
}

class Apple extends Fruit {

}

const apple = new Apple();
apple.eat(); // 继承了父类的eat方法，因此复用了eat逻辑
```

组合其实是一种设计模式，例如：

```js
class Knife {
  cut: () => {
    ...
  }
}

class Chef {
  knife: new Knife();
}

const chef = new Chef();
chef.knife.cut(); // chef包含了knife，因此复用cut的逻辑
```

其实从直观上看，继承更适合个体、抽象的概念，例如苹果之于水果，HttpError之于Error；而组合更适合平级的合作概念，例如轮胎和车架的组合，顶栏与内容区的组合。

前端更适合继承的场景还是组合的场景呢？显然是组合，因为从直观上讲，一个页面就是由各个部分组合而成，一步步拆解。很少遇到某个部分是从另一个部分继承得来的。

造成这个结果的一个重要原因是前端代码与UI有关，而UI属于非常具象的东西，很少需要抽象，相对地，后端开发则经常需要处理一些抽象问题。

这也是为什么大家在写前端代码的时候，很少会需要用到传统OOP的思想，很少用到`class`，甚至很少用到`new`这个操作符，大部分时候都是拼装、函数调用。比如同样是发送一个网络请求：

```js
// 这种代码比较常见
request('/api/blablabla').post(data);

// 这种代码比较少见
const request = new Request({ url: '/api/blablabla', data });
request.post();
```

上面的原因使得前端开发和后端开发有一些细微的差别，我说的是“味道”上的差别。假如一个后端开发临时拉过来做一些开发工作，写出来的代码大概率会让人觉得哪里不太对，说不上来的那种。甚至有些时候会让人感到困惑和难以理解，维护起来也容易陷入混乱。

所以，在保持一致的哲学之下，应该多用组合而不是继承，这也更符合前端开发的思考方式。

哦对了，在灵活性上看，组合比继承更加有优势，看，你又多了一个使用组合的理由。

# 4. “单一”优于“多样”

在现实中，“多样”总是优于“单一”。比如多样化饮食比单一结构饮食更有利于健康，比如多元的文化比单一文化更有利于文明进步，等等。
但是在代码世界中，“单一”比“多样”更合适，我们是在写代码不是在写诗。

代码风格要保持统一。对于没有明显好坏之分的写法风格分歧，应该毫不犹豫地选择遵从“传统”，少数服从多数。比如js是否加分号，真的没有什么区别，只是一种风格而已，但是如果大部分代码已经加了分号，那你就应该加分号。

除了代码风格之外，类型也应该保持一致。比如：

```js
// 函数返回类型不统一
function foo() {
  if (condition) {
    return 1;
  } else {
    return '2';
  }
}

// 变量类型不统一
let result = 1;
if (condition) {
  result = '2';
}
```

代码中唯一允许并且被鼓励的多样性是注释，请把你的个性表达在注释里吧。

```js
// 《UNESCO世界非物质文化遗产》
// 《全国重点文物保护单位》
// 《全国AAAAA级旅游景区》
//              —————— CEO赵欧伦同学在mage项目最后的几行代码
// 本文件需要施工请绕过下面几行

// 打卡围观群众
//   XXX
```

# 5. 先“业务逻辑”，后“技术模型”

典型的例子是项目的目录结构，比如现在有一个小项目，有两个业务，业务A，业务B。有关项目的组织形式有以下两种：

```sh
# 方案1
.
├── components
│   ├── feature1
│   │   └── ...
│   └── feature2
│       └── ...
└── containers
    ├── feature1
    │   └── ...
    └── feature2
        └── ...

# 方案2
.
├── feature1
│   ├── components
│   │   └── ...
│   └── containers
│       └── ...
└── feature2
    ├── components
    │   └── ...
    └── containers
        └── ...
```

方案1是先“技术模型”，后“业务逻辑”，即先按照技术模型上所谓的component/containers分类法分成了两个目录，然后各自的目录下面再按照业务逻辑分成feature1和feature2两个目录。

方案2是先“业务逻辑”，后“技术模型”，即先按照业务逻辑先划分为feathre1和feature2，然后每个feature目录下再划分成技术概念上的components和containers。

对于大型项目而言，方案2是更优的。原因有两点（也许还可以再编出来一点，等以后有精力再说吧）：

1. 容易理解。尽管一个研发团队中有各种各样角色，例如产品、开发、设计、测试，大家的专业技能和工作内容各不相同，但有一点是相同的，那就是大家都必须对业务逻辑有明确的、统一的认识，只有这样，大家才能共同协作生产出符合预期的产品。可见，业务逻辑作为一种“通用知识”或者“通用语言”，它应当被最先理解和掌握，然后才是去熟悉具体的代码。此时如果项目是按照“先业务逻辑”，后“技术模型”的方式组织，那么他就可以很容易地根据业务逻辑快速缩小范围然后深入技术细节。但如果是反过来，一开始看到的是技术层面的东西，业务逻辑隐藏在深处，那么可以想见的将会非常困难。
2. 容易维护。业务逻辑通常都是整块整块的，即一个业务逻辑的边界通常是比较容易分辨的。因此维护起来会比较方便，那一块交给谁负责维护，划分起来很自然。对应到代码上也是一样，如果代码也是优先按照业务逻辑设计，那么代码之间的边界也会自然清晰起来，这非常有利于维护。此外，业务逻辑通常是稳定的，但是技术方案可能日新月异，比如今天用redux，明天换成mobx。“业务优先”能够保证代码结构大体是稳定的，一个稳定的项目结构是非常可贵的。

上面的的这些只是一个例子，是在说明一个成熟可靠的技术方案，一定离不开它所生效的场景。脱离业务谈技术，就像脱离地球引力建造房屋一样，终究有一天会被大自然规律狠狠捶打。一个优秀的架构师一定是非常善于观察、理解和总结业务场景的。

先业务逻辑、后技术模型，可以帮你在某些场景做出更合适的决定。

# 6. “展示”与“逻辑”分离

如果二者耦合在一起，其中一方变化另一方也必须要跟着变化，改动和维护成本被人为增加了。

道理大家都懂，但说起来容易做起来难，如何识别展示与逻辑，以及如何设计出展示与逻辑分离的代码需要踩坑与积累。

举一个例子，现在我们手上有中国城市的数据，需要实现一个很原始的列表形式的选择组件，比如：

```jsx
const cityNames = ['北京', '上海', '广州', '深圳', ...];

<CitySelector options={} value={} onChange={}/>
```

可能会有两种方案：

方案1
```jsx
/**
 * @param {object} options
 * @param {string[]} options.cities - 城市列表
 * @param {string} options.value - 当前所选城市
 * @param {Function} options.onChange - onChange回调
 */
function CitySelector({ cities, value, onChange }) {
  return (
    <ul>
      {cities.map((city) => (
        <li
          className={value === city ? 'active' : ''}
          onClick={() => onChange(city)}
        >
          {city}
        </li>
      ))}
    </ul>
  );
}

// 调用方法
<CitySelector
  cities={['北京', '上海', '广州', '深圳', ...]}
  value={'上海'}
  onChange={(city) => updateCityAPI(city)}
/>
```

方案2
```jsx
/**
 * @param {object} options
 * @param {{ id: number, name: string }[]} options.cities - 城市列表
 * @param {number} options.value - 当前所选城市id
 * @param {Function} options.onChange - onChange回调
 */
function CitySelector({ cities, value, onChange }) {
  return (
    <ul>
      {cities.map((city) => (
        <li
          className={value === city.id ? 'active' : ''}
          onClick={() => onChange(city)}
        >
          {city.name}
        </li>
      ))}
    </ul>
  );
}

// 调用方法
<CitySelector
  cities={[{ id: 1, name: '北京' }, { id: 2, name: '上海'} , { id: 3, name: '广州' }, { id:4, name: '深圳' }, ...]}
  value={2}
  onChange={(city) => updateCityAPI(city)}
/>
```

这两种方案唯一的不同是方案1中城市的名字同时作为了被展示的内容与保存的数据，而方案2中城市的展示内容是name，保存的数据是id。

因为数据是属于业务逻辑的部分，因此显然方案1耦合了展示与逻辑，方案2分开了。

类似的还有很多例子，比如我们在url中保存筛选条件：

```
方案1
https://app.mokahr.com/?city=北京&degree=高中&commitment=全职

方案2
https://app.mokahr.com/?city=1&degree=3&commitment=2
```

比如后端接口返回的状态：

```js
// 方案1，直接保存一段文本
const API_STATUS = [
  '请求成功',
  '权限不足',
  '数据不存在',
  '未知错误',
  ...
];

// 方案2，保存的是code
const API_STATUS = [
  1,
  2,
  3,
  4,
  ...
]
```

比如定时发消息业务的后端逻辑设计：

```
方案1，直接把待发送的信息拼接好存在库里，发送的时候无脑取出来发送即可。

方案2，将待发送的信息元数据存下来，发送的时候将元数据重新还原拼接成完整内容再发送。
```

类似的例子还有很多，通过分析我们发现，要遵守展示与逻辑分离是有代价的，通常是导致开发成本更高了。因此，即使人们都明白这个道理，也仍然会不自觉地写出展示与逻辑耦合的代码，尤其是那些刚从学校毕业、缺乏大型项目开发经验、对Java嗤之以鼻的人。

如何避免这个问题呢？这里有一个小技巧，就是在设计枚举类型数据的时候，将枚举类型的值设计成非本地语言环境的。比如在中文语言环境下，将枚举类型的值设计成英文的，这样就逼迫开发者在实现展示逻辑的时候不得不做一次转换，从英文转换成中文，从而避免直接耦合的情况发生。

# 7. 不要沉迷于KISS，请保持适当的冗余

编程境界：

1. 第一重，狗屁不懂，全是复制粘贴
2. 第二重，知道代码复用并且尝到了甜头，见到重复代码就想合并。也许是因为接触到的项目规模都不大一个人就能hold住，或者是项目历史比较短，所以倒也没遇到什么大问题。
3. 第三重，因为过于追求代码复用开始遇到一些坑，比如改动一个地方另外一个地方坏了，或者代码里充斥了大量为了在不同场景下复用代码的if判断。渐渐地开始对KISS原则产生了怀疑。
4. 第四重，有点嫌弃甚至开始厌恶KISS原则，感到迷茫。尤其是当项目庞大或者历史悠久以后，代码耦合带来的问题比代码冗余带来的问题严重多了，有时候会过犹不及写出如“实习生”般大量冗余的代码被世人所嘲笑。第四重是一劫，很多人滞留在这里非常久时间甚至出不去了。
5. 第五重，经历九九八十一难，九九归一，人剑合一。何时抽象何时冗余大部分时候都了然于胸，基本不再迷茫，笑看各路英雄豪杰代码。
6. 第六重，看破红尘，代码的好坏终究只是细节，产品为王，于是转行不再写代码了。。。

开个玩笑，不过还是有一些道理在里面的。代码复用确实降低了代码冗余，但是却也让代码之间产生了依赖增加了耦合。

代码冗余的坏处是什么，是在修改的时候，容易少改而导致遗漏，该改的没改，进而导致bug。

代码耦合的坏处是什么，是在修改的时候，容易改多而导致误伤，不该改的地方受到改动的影响，进而导致bug。

冗余和耦合似乎是一个硬币的正反面，不可兼得。

对于大型、历史悠久、多人配合的项目来说，系统复杂度超乎想象，因此必然的解决是进行拆分多个模块，微服务化，使模块之间尽量独立、解耦，模块可独立部署更新。那么顺着这个思路，相同代码如果位于同一个模块则可以抽象复用，如果位于不同模块则应该冗余。不过这个思路实际上是把皮球踢给了一个新问题：“如何划分系统模块”，这是个更加复杂的领域，请搜索领域驱动设计。。。

# 8. 重要的放前面，不重要的放后面

人类在阅读代码的时候，随着代码行数的增加，注意力是会不断下降的，精力也会不断分散。其实人类在做任何事情的时候都是如此，不光大脑如此，身体也是如此。

假如一部电影，开头60分钟都是漫长的铺垫，那大部分观众可能就睡着了。等到后面高潮迭起突然惊醒，也看的是一脸懵逼。其实做任何事情都是这样，越是重要的东西，越是应该尽早交代。比如英文老师教导我们，如果考试的时候时间不多了，做阅读理解的时候每段话只看第一句就够了。就是合理的文章结构即是如此，先总后分，容易理解，非常科学。

写代码也是一样，对于顺序无关的代码片段，把重要的放前面，不重要的放后面，能更有助于他人理解代码。

什么是重要的？通常那些常用的、不一般的、影响很大的算是重要的。其他的是不重要的。做人也是一样，什么是重要的人，就是哪些经常出现的存在感很强的、能力很强的、影响力很大的人。

比如，我们在写React组件的时候，对于class组件，可能有人会纠结render函数应该放在第一个呢还是最后一个呢。

```jsx
// 方案1，render放第一个
class A extends Component {
  render() {
    ...
  }

  foo() {
    ...
  }

  bar() {
    ...
  }

  ...
}

// 方案2，render放最后一个
class A extends Component {
  foo() {
    ...
  }

  bar() {
    ...
  }

  ...

  render() {
    ...
  }
}
```

显然方案1更好咯。

# 9. 不要总想着翻天覆地式的大重构，应该渐进式地改变

翻天覆地式的大重构有三大坏处：

1. 开发困难。这个很好理解，都翻天覆地了，开发成本可不高吗。
2. 上线困难。因为代码改动太多，导致code review、测试的工作量也跟着变多，上线前的流程全部跑下来耗时很长。
3. 上线风险高。还是因为代码改动太多，出问题的概率就跟着增大了。而且一旦出问题，可能造成的影响也比较大。

因为我们是在做大型企业项目，团队里好多人一起协同，千万不要想着翻天覆地式的重构，不然你会死得很难看。

渐进式的改变，说的是那种小步快跑的形式。将一个巨大的改动拆分成若干可以独立上线的工作。比如我要重构1000个组件，渐进式的做法是一次重构100个，分10次重构完成。有些人可能认为这会很低效，从流程上讲上10次线肯定比上1次线更漫长，其实未必，因为每一步的改动变小了，导致每一次的开发、上线更容易了，风险也降低了，所以总得算下来可能更快了。

当然有些时候无法做到渐进式改变，或者强行渐进式改变会另成本急剧升高，这个时候就另当别论了。
